## Grammar for sound change formal notation
##
## Part of the `alteruphono` library;
## see: https://github.com/tresoldi/alteruphono

## TODO: should move all `recons` to `segment`?

#######################

## TODO: add support to segmentation boundary ("significant") whitespace
##       with plus signs or parentheses
## TODO: add syllable breaks
## TODO: Consider allowing single-line comments in future versions.
##       with @@eol_comments :: /##([^\n]*?)$/

## Define the grammar for parsing sound changes
@@grammar::SOUND_CHANGE

## The grammar `start` is defined as a "sound change rule" including
## the three basic elements: an `ante` sequence (mandatory), a `post`
## sequence (mandatory), and a `context` sequence (optional). `ante` and
## `post` are separated by `arrow` terminals, which are not captured;
## `post` and `context` are separated by `slash` terminals, which are not
## captured as well. Note that we match the end of string `$` to guarantee
## that no extra material is included in the string (such as comments).
start =
    | ante:SEQUENCE ARROW post:SEQUENCE SLASH context:SEQUENCE $
    | ante:SEQUENCE ARROW post:SEQUENCE $
    ;

## Collect a sequence of `segment`s; the grammar syntax here (with the
## override from the `@:` operator) guarantees that `choice`s are returned
## as list, while individual `segment`s are parsed "as is" in the AST.
## While a formally more elegant approach would be to have even single
## segments as lists, with the code logic in charge of abstracting it,
## this decision makes the exploration much easier and intuitive for
## people who are not accustomed with PEG grammars, and it also provides for
## easier and faster code when applying rules (as there are less queries).
## Note that `focus` is not listed among `segments`, as it cannot be
## repeated or used in an alternative by our definition.s
SEQUENCE = { SEQUENCE_ELEMENT }+ ;
SEQUENCE_ELEMENT =
    | "|".{ @:SEGMENT }+
    | focus:FOCUS
    ;

## Define segments as all basic units of sound or position (including
## empty ones) that can be part of a `choice`
## TODO: investigate on alternatives with empty, for optionality
## TODO: strange bug, but `ipa` cannot be capital; investigate
SEGMENT =
    | boundary:BOUNDARY
    | empty:EMPTY
    | BACKREF
    | SOUND_CLASS
    | ipa
    ;

## Define feature keys, features (which include keys and values), and feature
## descriptions (i.e., multiple features).
## As features can change across experiments, including due to named tiers,
## there is no point in listing the features; we accept any valid identifier
## as a key, delegating validation to code. Identifiers are composed of
## lowercase letters, digits, underscores, and dashes, with the first
## character a letter. In features, values can either precede and be an
## operator, or follow and be a string value. Features composed only
## of feature keys are accepts, with an implied positive value.
## Feature descriptions are composed of multiple features enclosed by
## square brackets and separated by commas.
## Please note that, unlike the somewhat analogous case of segment alternatives
## (`choice`), here the grammar will make 竜 TatSu capture this as
## a list also in cases of a single feature. This is intentional.
## TODO: allow values besides "true" and "false"
FEATURE_KEY = /[a-z][a-z0-9_-]+/ ;
FEATURE =
    | value:(r"+"|r"-"|r"!") key:FEATURE_KEY
    | key:FEATURE_KEY "=" value:(r"true"|r"false")
    | key:FEATURE_KEY
    ;
MODIFIER = [recons:RECONS] r"[" ",".{ @+:FEATURE }+ r"]" ;

## Defines a back-reference, an index with an optional modifier and
## reconstruction flag.
INDEX = /[0-9]+/;
BACKREF =
    | [recons:RECONS] "@" backref:INDEX modifier:MODIFIER
    | [recons:RECONS] "@" backref:INDEX
    ;

## Sound class labels are identifiers in uppercase letters or digits, with
## the first character obligatorily a letter.
## Sound class references can be optionally marked as reconstructions by
## a preceding asterisk, and optionally carry a feature description
## modifier.
SOUND_CLASS_LABEL = /[A-Z][A-Z0-9]*/ ;
SOUND_CLASS =
  | [recons:RECONS] sound_class:SOUND_CLASS_LABEL modifier:MODIFIER
  | [recons:RECONS] sound_class:SOUND_CLASS_LABEL
  ;

## Define additional capture symbols (actually terminals). Notes:
##   - the `arrow` and `slash` symbols are used but not captured
##   - `boundary` includes regex-standard "^" and "$", but these are matched
##     in whatever position
## TODO: add symbols for syllable and morpheme boundary
FOCUS = r"_";
BOUNDARY = r"#"|r"^"|r"$";
EMPTY = r":null:"|r"0";

## Define an IPA capture as all the characters which are non reserved;
## validation of the graphemes is carried after parsing, in code, and
## *not* in the grammar.
## TODO: compile list of reserved characters
## TODO: now that IPA is at the end, can we just match dot?
ipa = [recons:RECONS] grapheme:/[^ @_#^$=>0|*\/\-]+/ ;

## Reconstruction markers
RECONS = r"*" | r"**" ;

## Define non-capture terminals.
ARROW = r"==>" | r"-->" | r"->" | r"=>" | r">" | r"→" | r"⇒" | r"⇾" | r"»";
SLASH = r"//" | r"/" ;
