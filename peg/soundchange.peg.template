## Grammar for sound change formal notation
##
## Part of the `alteruphono` library;
## see: https://github.com/tresoldi/alteruphono

## Define the grammar for parsing sound changes
@@grammar::SOUND_CHANGE

## We define the `rule` starting symbol which includes the three basic
## elements of a sound change: a `source` (mandatory), a
## `target` (mandatory), and a `context` (optional). Sources and
## targets are separated by `arrow` terminals, which are not captured;
## targets and contexts are separated by `slash` terminals, also
## uncaptured.
#
## We also match the end of string `$` to guarantee that no extra material
## included in the string; if the user wants to add additional material,
## such as comments, it must be removed before the parsing.
## TODO: Consider allowing single-line comments in future versions.
start =
    | source:sequence arrow target:sequence slash context:sequence $
    | source:sequence arrow target:sequence $
    ;

## A `(sound) sequence` is defined as a sequence of one or more segments. It
## is implied that they are separated by a whitespace, and such we need no
## positive collection.
sequence = { segment }+ ;

## Define a segment, which can be:
##   - an IPA grapheme
##   - a sound class shorthand
##   - extra symbols such as sequence boundary, current position (only
##     used in contexts), and
##     zero/null sound (please note that these are accepted in all
##     sequences when parsing, including `source`, even though it makes
##     no sense there; such verification should however be carried by
##     the engine and not here by the parser, as it would make the
##     grammar unnecessarily complicated)
##   - a feature description, composed of a number of feature key/value
##     pairs delimited by square brackets
##   - a back-reference indicated by the at symbol ("@")
##   - a list of alternatives delimited by curly brackets
## TODO: add syllable breaks
## TODO: move all recons here?
## TODO: discuss the status of "mapper" (previously "alternative")
##
## NOTE: significant white-space is expressed by +
segment =
    | "+".{ segment }+
    | alternative
    | ipa
    | sound_class
    | boundary_symbol
    | position_symbol
    | null_symbol
    | feature_desc
    | back_ref
    | mapper
    ;

## Defines a feature description, composed of features separated by
## commas. Please note that 竜 TatSu will capture this as a list if and
## only if there is more than one item (otherwise, as a string).
## The feature can be preceded by a `recons` element indicating
## reconstructions.
## TODO: does it need `recons`?
## TODO: test `@+:e` to always capture lists
feature_desc = recons:[r"*"] r"[" ",".{ feature_desc:feature }+ r"]" ;

## Define a feature.
## TODO: Currently only supporting equality as operand, needs to be
##       updated when introducing support for numerical tiers.
feature =
    | value:feature_op key:feature_key
    | key:feature_key "=" value:feature_value
    | key:feature_key
    ;

## Defines a feature key symbol.
## As features can change across experiments, including due to named tiers,
## there is no point in listing the features; we will just accept any
## valid identifier.
feature_key = /[a-z][a-z0-9_-]+/ ;

## Define a feature value symbol.
## For the time being, we are only accepting binarized values.
feature_value =
    | r"true"
    | r"false"
    ;

## Define a feature operator symbol, which maps to values.
feature_op =
    | r"+"
    | r"-"
    | r"!" ## diverse from
    ;

## Defines a back-reference, which can be
##   - an index
##   - an index plus a modifier
## TODO: should back-references really have `recons` flags?
back_ref =
    | recons:[r"*"] "@" back_ref:/[0-9]+/ modifier:feature_desc
    | recons:[r"*"] "@" back_ref:/[0-9]+/
    ;

## Defines a list of alternatives, composed of sequences separated by
## commas. We don't have the problem of feature_desc here, of single items
## not being captured as lists, as alternatives must by definition have more
## than one item.
mapper = r"{" ",".{ mapper:sequence }+ r"}" ;

## Defines an alternative
## TODO: currently only supporting IPA
## TODO: add parentheses support
alternative = alternative:"|".{ ipa }+ ; 

## Define terminals

## Define "arrow" and "slash" symbols, used by `start` and not captured
arrow = r">" | r"->" | r"-->" | r"=>" | r"==>" | r"→" | r"⇒" | r"⇢" | r"⇾" | r"»";
slash = r"/" | r"//" ;

## Define additional symbols; null symbol includes Danish ø letter
## TODO: NULL would be a valid sound class name...
boundary_symbol = boundary:r"#";
position_symbol = position:r"_";
null_symbol = null:(r"NULL"|r"∅"|r"0"|r"ø"|r"Ø");

## Define the IPA graphemes as an alternation.
## Graphemes must be listed in inverse length order (longer to
## shorter) in order to guarantee that those composed of two or more
## characters will correctly be captured as such (especially in the
## case of affricates, which will otherwise be captured as
## plosive plus fricative).
##
## The alternation list can be generated from Python with the following code;
## we sort both in inverse length and alphabetical order, as well as remove
## some graphemes that are not suitable.
## TODO: move to a list of raw strings (i.e., no regular expression?)
## TODO: rename IPA to grapheme, as it is more correct (custom systems/
##        symbols)
ipa =
    recons:[r"*"]
    ipa:(sound_class|boundary_symbol|$$IPA_REPLACE$$)
;

## Define a soundclass shorthand.
sound_class =
    recons:[r"*"]
    sound_class:/[A-Z][A-Z0-9]*/
    ;
